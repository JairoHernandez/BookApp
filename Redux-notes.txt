------Reducers------

A reducer is a function that returns(generates) a piece of the application state.
Because our application can have many different pieces of state we can have many 
different reducers.

BOOK app

    Application State(big object) - Generated by Reducers
        1 reducer responsible for 'List of Books' -- Books Reducer
        1 reducer for 'Currently Selected Book' -- ActiveBook Reduder
    
    Each key(books, activeBook) in the application object is a state(aka piece of state).

    {
        books: [{title: 'Harry Potter'}, {title: 'Javascript'}], // books piece of state is produced by Books Reducer
        activeBook: {title: 'Javascript: The Good Parts'} // activeBook piece of state is produced by ActiveBook Reducer
    }

    Each value is a Reducer that changes its piece of the state(key).
    The reducer is a function that returns a value.

------Containers - Connecting Redux to React------

Test that are generating useable state.
react-redux library connects React with Redux. It's already in our package.json boiler plate.

A container is a react component with a direct connection to the state managed by redux.
It's the middle box in the diagram.

    containers/book-list-js
        // CONTAINER
        class BookList extends Component {

    Offial Redux docs say when React compoment has no conneciton to redux it's called dumb
    component. When there is a connection to Redux it's called a smart component.

------Containers Continued------  
Which component do we want to turn into a container?
    
    It varies. In general we want the most parent component that cares about a particular 
    piece of state to be a component.
        - Top level App should be a dumb component, thus NOT a Container because it does not touch
        the data inside of Redux.
        - BookList and BookDetail should both be Containers(aka smart components) because it 
        touches and cares about the Redux data(aka pieces of state).

ONLY THE MOST PARENT COMPONENT THAT USES A SPECIFIC PIECE OF STATE NEEDS TO BE CONNECTED TO REDUX!
Because of this we promoted book-list.js to be a Container.

------Implementation of Container Class------  

Again react-redux is the glue to connecting React and Redux via its 'connect' function.

    containers/book-list.js
        import { connect } from 'react-redux';

'connect' takes a function and a component and produces a container. The container is a 
component that is aware of the state contanied in Redux.

------Containers and Reducers Review------  

1. Define your reducer containing your application data(state) via reducer_books.js
2. Add reducer to combine reducer call. 

    reducers/index.js
        import { combineReducers } from 'redux';
        import BooksReducer from './reducer_books';

        const rootReducer = combineReducers({
             // The rootReducer adds a key to called 'books' to global application state.
             // And it value is whatever get's returned from booksReducer, which is our array of books.
            books: BooksReducer
        });

        export default rootReducer;

3. To make class BookList aware of the state in the Reducer we promoted it to a container by first 
importing

    containers/book-list.js
        import { connect } from 'react-redux';

and then defined 

    function mapStateToProps(state)

to hook component to function mapStateToProps

    export default connect(mapStateToProps)(BookList); 

4. When application state changes the containers re-renders.

------Actions and Action Creators------  

Action creator is just a function that returns and action.
And action flows thru reducers to decide to whether or not state needs to changed via Redux

Just like binding reducer to Container smart component BookList(book-list.js) you do the same
for action creator. You bind it to Container smart component BookList(book-list.js).
This allow action creator to flow through the reducer.

    containers/book-list.js
        import { bindActionCreators } from 'redux';

------Creating an Action------  

 Actions usually have 2 values: type and payload.
    type is purpose of an action

------Consuming Actions in Reducers------  

Reducers get 2 arguments:  state & action.
Only called when there's an action dispatched by out app.

Redux does not allow a reducer to return undefined or else it will throw an error.
You must always return a non-undefined value -- state=null.

------Conditional Rendering------  

If you dont have a "reasonable" state at bootup/loading of page you will see
this error:

    Uncaught TypeError: Cannot read property 'title' of null

so use this workaround

        if (!this.props.book) {
            return (<div>Select a book to get started.</div>);
        }

------Reducers and Action Review------  

class BookDetail extends Component {
    
    // this is component state.
    this.state.whatever // completely different/separate than Application redux state

Application state is formed by reducers.

Reducers all get tied together with combineReducers method in reducers/index.js
For each key we assgined 1 reducer.
    const rootReducer = combineReducers({
        books: BooksReducer,
        activeBook: ActiveBook
Reducers are in charge of manipulating state over time and do that through the use of actions that are dispatched.
Once the action is dispatched the reducer flows through the different options to either change the state or keep 
it the same based on the type of action received.
Actions must always hve a type and optional payload(typical name but you can call it something else).
        
        actions/index.js
            type: 'BOOK_SELECTED',
            payload: book